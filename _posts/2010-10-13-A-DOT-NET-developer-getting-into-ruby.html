---
layout: post
title: A .NET developer getting into Ruby
description: How I got to know Ruby and why I decided to explore it.
categories: [ruby, dotnet]
---

<span class="date">
Filed under
            {% for temp in categories %}
                {{ temp }},
            {% endfor %}
</span>
<p class="infop">
I probably got to know {% include rubyanchor.html %}, and it’s {% include rubyonrailsanchor.html %} framework, when I started to work with 
{% include aspdotnetmvcanchor.html %}, and while learning about the latter (it’s) architecture, structure and development paradigm, I discovered the similarities 
between the two frameworks ({% include rubyonrailsanchor.html %} and {% include aspdotnetmvcanchor.html %}), has it had been suggested by one of 
my former co-workers at the company that I used to work at.
</p>

<p class="infop">
I’ve always worked with {% include aspdotnetanchor.html %} at my work, occasionally working with other server side technologies such as {% include phpanchor.html %} 
or {% include pythonanchor.html %}. About two years ago, 
we, at the company that I used to work at, decided to try this new framework, {% include aspdotnetmvcanchor.html %}, with (or in) some of the new projects.
</p>

<p class="infop">
We were excited to explore new/old concepts (ex: {% include mvcanchor.html %}, convention over configuration), solution architecture (dynamic languages architectures), 
new/old development methodologies (ex: {% include tddanchor.html %}) and to have control again over on what’s generated to client. I said new/old because none of these 
concepts is actually really ‘new’. They’ve been around for a while, fully supported in other frameworks, but you had to work your way around 
the framework in order to apply them. This time it’s little different. The framework itself enforces you to apply the concepts and best practices.
</p>

<p class="infop">
{% include aspdotnetmvcanchor.html %} is a lovely piece of software that allows you to build web applications based on the {% include mvcanchor.html %} 
software design pattern. The first versions of the framework were released late 2007 and the last stable version dates from March 2010. In an environment 
overcrowded with web forms, post backs, view states and code-behind(ed) views, it came as an alternative to what it was standard in the classic 
{% include aspdotnetanchor.html %}, by offering the developers the chance to gain control again over HTML and be able to generate clean view, 
with just pure HTML. Most of the times, with web forms, you don’t work directly with HTML, unless you want to re-invent the wheel. 
No more cumbersome pages with view state and strange id’s, and no obtrusive JavaScript, JavaScript integration (ex: Ajax, {% include jqueryanchor.html %}, 
{% include jsonanchor.html %}) is easy and clean. 
It also brought the following separation of concerns: views have no logic and only display information (presentation layer); controllers receive incoming 
requests and bridge the view with the model (middle layer); the model comprises the business rules and the data access (business and data access layer). 
These layers are totally independent allowing flexibility, when it comes to build and maintain the application, and testability.
</p>

<blockquote>
<span class="leftQuote">&#8220;</span><span class="quoteContent">
MVC is a software design pattern that defines project architecture in terms of a model-view-controller, the three key components of the design pattern.
The model contains the domain and the business rules of the application. It also has the data access (ORM).
The view is the presentation layer and is as dummy as it can get, for it’s only purpose is to display information returned from an interaction with the server.
The controller is the key layer that bridges the view with the model and receives incoming requests, 
redirecting them to the model and later returning the response to client with the selected view.
<span class="rightQuote">&#8221;</span></span>
</blockquote>

<p class="infop">
The new framework also emphasized convention over configuration (I guess it’s self explained), dry and simple as possible solution, 
{% include tddanchor.html %} (Test Driven Development) and Agile Development methodologies (ex: {% include scrumanchor.html %}). It’s not like it’s something embedded in the 
framework when it comes to agile but there some details that make it easier to work your way with Agile such as ActiveRecord, 
Rails and Rake. These let you build and track changes in the application seamlessly. Another supported feature is {% include restanchor.html %}. With 
{% include restanchor.html %}, 
client requests don’t target document yet a resource to be consumed.
</p>

<p class="infop">
After working for a while with {% include aspdotnetmvcanchor.html %}, I decided to try both {% include rubyanchor.html %} and {% include rubyonrailsanchor.html %}. 
It felt natural in order to understand better the .NET MVC framework, and while I was at it, 
to try something new. Being both {% include mvcanchor.html %} frameworks was easy to understand its structure and workflow. 
The major difference came from the language itself, which I was unfamiliar with. Yet with a bit of 
reading and practice I was building already my first web applications with {% include rubyanchor.html %}. I’m still 
working my way around {% include rubyanchor.html %}, while improving my way around with {% include aspdotnetmvcanchor.html %}, but I believe it won’t take 
too much time till start developing some decent applications with {% include rubyonrailsanchor.html %}. I’ll be keeping you posted with my progress.
</p>

<br /> 
Cheers,
